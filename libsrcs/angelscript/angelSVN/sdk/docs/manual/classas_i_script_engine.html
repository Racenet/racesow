<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>AngelScript: asIScriptEngine Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">AngelScript
   
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classas_i_script_engine.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">asIScriptEngine Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="asIScriptEngine" -->
<p>The engine interface.  
 <a href="classas_i_script_engine.html#details">More...</a></p>

<p><a href="classas_i_script_engine-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Memory management</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#aa95a5d9b5d9e7e6a230fedf056eaf8ce">AddRef</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase reference counter.  <a href="#aa95a5d9b5d9e7e6a230fedf056eaf8ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#aae91a45da75af9234b87e825b5c08b81">Release</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrease reference counter.  <a href="#aae91a45da75af9234b87e825b5c08b81"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Engine properties</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a1bce4e5f573a2ca0ff55163e28f761dd">SetEngineProperty</a> (<a class="el" href="angelscript_8h.html#a53c2e8a74ade77c928316396394ebe0f">asEEngineProp</a> property, <a class="el" href="angelscript_8h.html#a76fc6994aba7ff6c685a62c273c057e3">asPWORD</a> value)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically change some engine properties.  <a href="#a1bce4e5f573a2ca0ff55163e28f761dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="angelscript_8h.html#a76fc6994aba7ff6c685a62c273c057e3">asPWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a5531bf5310a0c933aa698725a6828e5f">GetEngineProperty</a> (<a class="el" href="angelscript_8h.html#a53c2e8a74ade77c928316396394ebe0f">asEEngineProp</a> property) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve current engine property settings.  <a href="#a5531bf5310a0c933aa698725a6828e5f"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Compiler messages</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a74192fe950808eb72a64e3e371f0ea02">SetMessageCallback</a> (const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;callback, void *obj, <a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> callConv)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a message callback that will receive compiler messages.  <a href="#a74192fe950808eb72a64e3e371f0ea02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#ada64567fc9621e5e98160c7f03efa064">ClearMessageCallback</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the registered message callback routine.  <a href="#ada64567fc9621e5e98160c7f03efa064"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a936ce6566af958bb75ba1c0945d8b03a">WriteMessage</a> (const char *section, int row, int col, <a class="el" href="angelscript_8h.html#a8badcd23652646db5c5c6981dc73d4f5">asEMsgType</a> type, const char *message)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a message to the message callback.  <a href="#a936ce6566af958bb75ba1c0945d8b03a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">JIT compiler</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee4f910163604203a27db1ffea3b1c9c"></a><!-- doxytag: member="asIScriptEngine::SetJITCompiler" ref="aee4f910163604203a27db1ffea3b1c9c" args="(asIJITCompiler *compiler)=0" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#aee4f910163604203a27db1ffea3b1c9c">SetJITCompiler</a> (<a class="el" href="classas_i_j_i_t_compiler.html">asIJITCompiler</a> *compiler)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the JIT compiler. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fb6db9085df3c7d487c0d58de76bb83"></a><!-- doxytag: member="asIScriptEngine::GetJITCompiler" ref="a2fb6db9085df3c7d487c0d58de76bb83" args="() const =0" -->
virtual <a class="el" href="classas_i_j_i_t_compiler.html">asIJITCompiler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a2fb6db9085df3c7d487c0d58de76bb83">GetJITCompiler</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the JIT compiler. <br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Global functions</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a754fafd069d8e0c19baff2dc222893b0">RegisterGlobalFunction</a> (const char *declaration, const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;funcPointer, <a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> callConv)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a global function.  <a href="#a754fafd069d8e0c19baff2dc222893b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a72aa1a3a5ac88a5a1dba4fa3655141d6">GetGlobalFunctionCount</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of registered functions.  <a href="#a72aa1a3a5ac88a5a1dba4fa3655141d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a154f25c36b7d88f73de1b440a169ec08">GetGlobalFunctionIdByIndex</a> (<a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> index) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the function id of the registered function.  <a href="#a154f25c36b7d88f73de1b440a169ec08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classas_i_script_function.html">asIScriptFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#aaf2b79cef75adb4099a24e3412e4ea79">GetGlobalFunctionByIndex</a> (<a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> index) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the registered function.  <a href="#aaf2b79cef75adb4099a24e3412e4ea79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classas_i_script_function.html">asIScriptFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a42edd02e95731c795e13706400e8665a">GetGlobalFunctionByDecl</a> (const char *declaration) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the registered function.  <a href="#a42edd02e95731c795e13706400e8665a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Global properties</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#aacd32f32b2922b8ffaed204812013169">RegisterGlobalProperty</a> (const char *declaration, void *pointer)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a global property.  <a href="#aacd32f32b2922b8ffaed204812013169"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#aa69f6b37f9c7bdf9b52b9c1692daf048">GetGlobalPropertyCount</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of registered global properties.  <a href="#aa69f6b37f9c7bdf9b52b9c1692daf048"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a93bd686853a48647d2136792e27380fb">GetGlobalPropertyByIndex</a> (<a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> index, const char **name, const char **nameSpace=0, int *typeId=0, bool *isConst=0, const char **configGroup=0, void **pointer=0, <a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> *accessMask=0) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the detail on the registered global property.  <a href="#a93bd686853a48647d2136792e27380fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a07e85878869e4d0597c1177d767dc717">GetGlobalPropertyIndexByName</a> (const char *name) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the property.  <a href="#a07e85878869e4d0597c1177d767dc717"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a91a4cc8af51ca439ca82b9b6630439b3">GetGlobalPropertyIndexByDecl</a> (const char *decl) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the property.  <a href="#a91a4cc8af51ca439ca82b9b6630439b3"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Object types</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a29c6c087c8c5b5cdb6271cfd161cc5a6">RegisterObjectType</a> (const char *obj, int byteSize, <a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> flags)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new object type.  <a href="#a29c6c087c8c5b5cdb6271cfd161cc5a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a33f3cd249307f5f11120a395579410f6">RegisterObjectProperty</a> (const char *obj, const char *declaration, int byteOffset)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a property for the object type.  <a href="#a33f3cd249307f5f11120a395579410f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a6686c12ef37f4a4b1f9e90997b4756d0">RegisterObjectMethod</a> (const char *obj, const char *declaration, const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;funcPointer, <a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> callConv)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a method for the object type.  <a href="#a6686c12ef37f4a4b1f9e90997b4756d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a7ea3c93dea338b0287027de0e4895dcb">RegisterObjectBehaviour</a> (const char *obj, <a class="el" href="angelscript_8h.html#a7e38df5b10ec8cbf2a688f1d114097c5">asEBehaviours</a> behaviour, const char *declaration, const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;funcPointer, <a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> callConv)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a behaviour for the object type.  <a href="#a7ea3c93dea338b0287027de0e4895dcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#ae2d89b82561b7f9843f35693c664589f">RegisterInterface</a> (const char *name)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an interface.  <a href="#ae2d89b82561b7f9843f35693c664589f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a43bd2c12c94a55c22be76d209de93f1a">RegisterInterfaceMethod</a> (const char *intf, const char *declaration)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an interface method.  <a href="#a43bd2c12c94a55c22be76d209de93f1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#ac2667fbe30dd00ed14bc14e6ef7fc725">GetObjectTypeCount</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of registered object types.  <a href="#ac2667fbe30dd00ed14bc14e6ef7fc725"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classas_i_object_type.html">asIObjectType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#ac0a40a93ca9df41b7e56dd846a98cd92">GetObjectTypeByIndex</a> (<a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> index) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object type interface by index.  <a href="#ac0a40a93ca9df41b7e56dd846a98cd92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classas_i_object_type.html">asIObjectType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a4c44c6cc32407c92d0bb4dfb871ee943">GetObjectTypeByName</a> (const char *name) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matching object type by name.  <a href="#a4c44c6cc32407c92d0bb4dfb871ee943"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">String factory</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a95ad30812d89dee425240b49675017a4">RegisterStringFactory</a> (const char *datatype, const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;factoryFunc, <a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> callConv)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the string factory.  <a href="#a95ad30812d89dee425240b49675017a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a0bc701479de273e47e6ed6276e8fbb3e">GetStringFactoryReturnTypeId</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type id of the type that the string factory returns.  <a href="#a0bc701479de273e47e6ed6276e8fbb3e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Default array type</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#ac9451feece1297eba8d1649036039e82">RegisterDefaultArrayType</a> (const char *type)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the type that should be used as the default array.  <a href="#ac9451feece1297eba8d1649036039e82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#ae86e5444979b0abd92777be83c53fc80">GetDefaultArrayTypeId</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type id of the registered type.  <a href="#ae86e5444979b0abd92777be83c53fc80"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Enums</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#abed6e77f2a532c8a4f528650fa137d37">RegisterEnum</a> (const char *type)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an enum type.  <a href="#abed6e77f2a532c8a4f528650fa137d37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a4d331153596dd39838f3bed2a861af18">RegisterEnumValue</a> (const char *type, const char *name, int value)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an enum value.  <a href="#a4d331153596dd39838f3bed2a861af18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a4b4307dab64061be43db84ffb97e3782">GetEnumCount</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of registered enum types.  <a href="#a4b4307dab64061be43db84ffb97e3782"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a6c382e818034e25ba75a7683ccd7ef23">GetEnumByIndex</a> (<a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> index, int *enumTypeId, const char **nameSpace=0, const char **configGroup=0, <a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> *accessMask=0) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the registered enum type.  <a href="#a6c382e818034e25ba75a7683ccd7ef23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#afe82935052b582efbfd536ebda352e98">GetEnumValueCount</a> (int enumTypeId) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of enum values for the enum type.  <a href="#afe82935052b582efbfd536ebda352e98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#acc50d55c389409e3ff699a5e4d6e4ba5">GetEnumValueByIndex</a> (int enumTypeId, <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> index, int *outValue) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name and value of the enum value for the enum type.  <a href="#acc50d55c389409e3ff699a5e4d6e4ba5"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Funcdefs</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a03c1a2cc23ae4b742c927f3472a1a4f7">RegisterFuncdef</a> (const char *decl)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a function definition.  <a href="#a03c1a2cc23ae4b742c927f3472a1a4f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a48aceb1556f88ce3bec3e0f84abe127f">GetFuncdefCount</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of registered function definitions.  <a href="#a48aceb1556f88ce3bec3e0f84abe127f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classas_i_script_function.html">asIScriptFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a62dc5e5ba69722ea177a8e7c509d13b3">GetFuncdefByIndex</a> (<a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> index) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a registered function definition.  <a href="#a62dc5e5ba69722ea177a8e7c509d13b3"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Typedefs</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#addb24466769dc52be96c7e37d5305245">RegisterTypedef</a> (const char *type, const char *decl)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a typedef.  <a href="#addb24466769dc52be96c7e37d5305245"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a0ebbbb86ea0e314cc2695f6276ebe507">GetTypedefCount</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of registered typedefs.  <a href="#a0ebbbb86ea0e314cc2695f6276ebe507"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a5ac7f06ad290ac619d48baaccedac7e4">GetTypedefByIndex</a> (<a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> index, int *typeId, const char **nameSpace=0, const char **configGroup=0, <a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> *accessMask=0) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a registered typedef.  <a href="#a5ac7f06ad290ac619d48baaccedac7e4"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Configuration groups</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#ac81014e50dd7efc1920adcb3fd2d1e5d">BeginConfigGroup</a> (const char *groupName)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a new dynamic configuration group.  <a href="#ac81014e50dd7efc1920adcb3fd2d1e5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a4cc5ed7ea71811655f7910d298bb5a02">EndConfigGroup</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the configuration group.  <a href="#a4cc5ed7ea71811655f7910d298bb5a02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#ab607be7fe727cdcce502d2beedbf4c0a">RemoveConfigGroup</a> (const char *groupName)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a previously registered configuration group.  <a href="#ab607be7fe727cdcce502d2beedbf4c0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a570df3e676f2d9e03e87d97b8cede1c7">SetDefaultAccessMask</a> (<a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> defaultMask)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the access mask that should be used for subsequent registered entities.  <a href="#a570df3e676f2d9e03e87d97b8cede1c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a605f114814f1f64804c04391816d948b">SetDefaultNamespace</a> (const char *nameSpace)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current default namespace for registrations and searches.  <a href="#a605f114814f1f64804c04391816d948b"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Script modules</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classas_i_script_module.html">asIScriptModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a9f7cdc52b59034e6e55eb8a56b427aa4">GetModule</a> (const char *module, <a class="el" href="angelscript_8h.html#ae4cf50de5273eb8c03c6e91e6e014f0c">asEGMFlags</a> flag=asGM_ONLY_IF_EXISTS)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an interface pointer to the module.  <a href="#a9f7cdc52b59034e6e55eb8a56b427aa4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#afb0ce55e5846eb18afdcf906aeb67cf7">DiscardModule</a> (const char *module)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Discard a module.  <a href="#afb0ce55e5846eb18afdcf906aeb67cf7"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Script functions</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classas_i_script_function.html">asIScriptFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#aaf67dc0b1f26be437ccbcc0ac5f330c9">GetFunctionById</a> (int funcId) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the function by its id.  <a href="#aaf67dc0b1f26be437ccbcc0ac5f330c9"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Type identification</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classas_i_object_type.html">asIObjectType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a52f3e08240c9fc493793036721cbd5ce">GetObjectTypeById</a> (int typeId) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object type interface for type.  <a href="#a52f3e08240c9fc493793036721cbd5ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#ad1f6fecb0f53fd7966736b01f65c3dcb">GetTypeIdByDecl</a> (const char *decl) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type id by declaration.  <a href="#ad1f6fecb0f53fd7966736b01f65c3dcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a3ae23fcde6af0d816ff97097cd443281">GetTypeDeclaration</a> (int typeId, bool includeNamespace=false) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a type declaration.  <a href="#a3ae23fcde6af0d816ff97097cd443281"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a39b7207a6c4c55a5cbf10eab2ccfb8e6">GetSizeOfPrimitiveType</a> (int typeId) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of a primitive type.  <a href="#a39b7207a6c4c55a5cbf10eab2ccfb8e6"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Script execution</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classas_i_script_context.html">asIScriptContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a2630e1cd03ffab0fee9b820bf0afe42a">CreateContext</a> ()=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new script context.  <a href="#a2630e1cd03ffab0fee9b820bf0afe42a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#afdc06a65b6df9095835a32fa474c99d3">CreateScriptObject</a> (int typeId)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a script object defined by its type id.  <a href="#afdc06a65b6df9095835a32fa474c99d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a0369a333503be2a232580a85b854779c">CreateScriptObjectCopy</a> (void *obj, int typeId)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of a script object.  <a href="#a0369a333503be2a232580a85b854779c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#ad299a2adb48c7510e3a167d8cea36789">CopyScriptObject</a> (void *dstObj, void *srcObj, int typeId)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy one script object to another.  <a href="#ad299a2adb48c7510e3a167d8cea36789"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a3660c6a075d76df0071b6df35feb227a">ReleaseScriptObject</a> (void *obj, int typeId)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the script object pointer.  <a href="#a3660c6a075d76df0071b6df35feb227a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a643746a83d3c1ba30cae7df40558bd13">ReleaseScriptObject</a> (void *obj, const <a class="el" href="classas_i_object_type.html">asIObjectType</a> *type)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the script object pointer.  <a href="#a643746a83d3c1ba30cae7df40558bd13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a9b4264280709ed2e97c763a2e0b1f282">AddRefScriptObject</a> (void *obj, int typeId)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the reference counter for the script object.  <a href="#a9b4264280709ed2e97c763a2e0b1f282"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a065c31d3fe1caaf3581d4a914d03c258">AddRefScriptObject</a> (void *obj, const <a class="el" href="classas_i_object_type.html">asIObjectType</a> *type)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the reference counter for the script object.  <a href="#a065c31d3fe1caaf3581d4a914d03c258"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a282b92f29b371545a6a6f6aa2ccf971e">IsHandleCompatibleWithObject</a> (void *obj, int objTypeId, int handleTypeId) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the object referenced by a handle compatible with the specified type.  <a href="#a282b92f29b371545a6a6f6aa2ccf971e"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">String interpretation</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="angelscript_8h.html#a012a602727ca3fe1efa27053bc58cbca">asETokenClass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#adb8d7ba77b0b24abea68ba93ac153668">ParseToken</a> (const char *string, size_t stringLength=0, int *tokenLength=0) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the class and length of the first token in the string.  <a href="#adb8d7ba77b0b24abea68ba93ac153668"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Garbage collection</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a4beff0f3d176199019c60d282e87c8d1">GarbageCollect</a> (<a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> flags=asGC_FULL_CYCLE)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform garbage collection.  <a href="#a4beff0f3d176199019c60d282e87c8d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a166e6cdd0cb35bcfd942824d8e882783">GetGCStatistics</a> (<a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> *currentSize, <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> *totalDestroyed=0, <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> *totalDetected=0, <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> *newObjects=0, <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> *totalNewDestroyed=0) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain statistics from the garbage collector.  <a href="#a166e6cdd0cb35bcfd942824d8e882783"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#abad64f5d62458c49acba7c0d9baf1279">NotifyGarbageCollectorOfNewObject</a> (void *obj, <a class="el" href="classas_i_object_type.html">asIObjectType</a> *type)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the garbage collector of a new object that needs to be managed.  <a href="#abad64f5d62458c49acba7c0d9baf1279"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a58ceeafd780dea3543e0ede4106199fd">GCEnumCallback</a> (void *reference)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by the garbage collector to enumerate all references held by an object.  <a href="#a58ceeafd780dea3543e0ede4106199fd"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">User data</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a339b31c7aea69e4132ae7cebc55f3e80">SetUserData</a> (void *data)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the memory address of some user data.  <a href="#a339b31c7aea69e4132ae7cebc55f3e80"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#aeab55f7073163d10552e02a469b0ef78">GetUserData</a> () const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the address of the previously registered user data.  <a href="#aeab55f7073163d10552e02a469b0ef78"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#ad91d8c1e53489bee1243e351be7e18a9">SetEngineUserDataCleanupCallback</a> (<a class="el" href="angelscript_8h.html#ab4583fe7648248c59f525f944cfb9db1">asCLEANENGINEFUNC_t</a> callback)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the function that should be called when the engine is destroyed.  <a href="#ad91d8c1e53489bee1243e351be7e18a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#afb7a5e52a2232262ef2863e58bb2c7d1">SetModuleUserDataCleanupCallback</a> (<a class="el" href="angelscript_8h.html#a90d681aba2f00b701425d4dbdca3375b">asCLEANMODULEFUNC_t</a> callback)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the function that should be called when the module is destroyed.  <a href="#afb7a5e52a2232262ef2863e58bb2c7d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#aafa5ed8214fc2029a6b5228e5cf60d6e">SetContextUserDataCleanupCallback</a> (<a class="el" href="angelscript_8h.html#a88ecc3288f67d86c6dd9d8d24d9980ca">asCLEANCONTEXTFUNC_t</a> callback)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the function that should be called when a context is destroyed.  <a href="#aafa5ed8214fc2029a6b5228e5cf60d6e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#ae9585d4e65618b02c6005d3beaca4377">SetFunctionUserDataCleanupCallback</a> (<a class="el" href="angelscript_8h.html#ae396d162d9d46c34a7f197ecbc788dfa">asCLEANFUNCTIONFUNC_t</a> callback)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the function that should be called when a function is destroyed.  <a href="#ae9585d4e65618b02c6005d3beaca4377"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classas_i_script_engine.html#a7495c0b6307bb983ff807a3c31c4f938">SetObjectTypeUserDataCleanupCallback</a> (<a class="el" href="angelscript_8h.html#a8bbbe3a90082461266acf8f98ce9216e">asCLEANOBJECTTYPEFUNC_t</a> callback)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the function that should be called when an object type is destroyed.  <a href="#a7495c0b6307bb983ff807a3c31c4f938"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>It is allowed to have multiple instances of script engines, but there is rarely a need for it. Even if the application needs to expose different interfaces to different types of scripts this can usually be accomplished through the use of dynamic configuration groups and access profiles. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa95a5d9b5d9e7e6a230fedf056eaf8ce"></a><!-- doxytag: member="asIScriptEngine::AddRef" ref="aa95a5d9b5d9e7e6a230fedf056eaf8ce" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::AddRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of references to this object.</dd></dl>
<p>Call this method when storing an additional reference to the object. Remember that the first reference that is received from <a class="el" href="angelscript_8h.html#af84c6359750675bf3ceccf373286a533">asCreateScriptEngine</a> is already accounted for. </p>

</div>
</div>
<a class="anchor" id="a9b4264280709ed2e97c763a2e0b1f282"></a><!-- doxytag: member="asIScriptEngine::AddRefScriptObject" ref="a9b4264280709ed2e97c763a2e0b1f282" args="(void *obj, int typeId)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::AddRefScriptObject </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">typeId</td><td>The type id of the object.</td></tr>
  </table>
  </dd>
</dl>
<p>This calls the add ref method of the object to increase the reference count.</p>
<p>This only works for objects.</p>
<p>This version is slightly slower than the <a class="el" href="classas_i_script_engine.html#a065c31d3fe1caaf3581d4a914d03c258">AddRefScriptObject(void*, const asIObjectType *)</a> variant. </p>

</div>
</div>
<a class="anchor" id="a065c31d3fe1caaf3581d4a914d03c258"></a><!-- doxytag: member="asIScriptEngine::AddRefScriptObject" ref="a065c31d3fe1caaf3581d4a914d03c258" args="(void *obj, const asIObjectType *type)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::AddRefScriptObject </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classas_i_object_type.html">asIObjectType</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type of the object.</td></tr>
  </table>
  </dd>
</dl>
<p>This calls the add ref method of the object to increase the reference count. </p>

</div>
</div>
<a class="anchor" id="ac81014e50dd7efc1920adcb3fd2d1e5d"></a><!-- doxytag: member="asIScriptEngine::BeginConfigGroup" ref="ac81014e50dd7efc1920adcb3fd2d1e5d" args="(const char *groupName)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::BeginConfigGroup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>groupName</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">groupName</td><td>The name of the configuration group </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asNAME_TAKEN</td><td>Another group with the same name already exists. </td></tr>
    <tr><td class="paramname">asNOT_SUPPORTED</td><td>Nesting configuration groups is not supported.</td></tr>
  </table>
  </dd>
</dl>
<p>Starts a new dynamic configuration group. This group can be setup so that it is only visible to specific modules, and it can also be removed when it is no longer used.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="doc_adv_dynamic_config.html">Dynamic configurations</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ada64567fc9621e5e98160c7f03efa064"></a><!-- doxytag: member="asIScriptEngine::ClearMessageCallback" ref="ada64567fc9621e5e98160c7f03efa064" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::ClearMessageCallback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error.</dd></dl>
<p>Call this method to remove the message callback. </p>

</div>
</div>
<a class="anchor" id="ad299a2adb48c7510e3a167d8cea36789"></a><!-- doxytag: member="asIScriptEngine::CopyScriptObject" ref="ad299a2adb48c7510e3a167d8cea36789" args="(void *dstObj, void *srcObj, int typeId)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::CopyScriptObject </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dstObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>srcObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dstObj</td><td>A pointer to the destination object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">srcObj</td><td>A pointer to the source object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">typeId</td><td>The type id of the objects.</td></tr>
  </table>
  </dd>
</dl>
<p>This calls the assignment operator to copy the object from one to the other.</p>
<p>This only works for objects. </p>

</div>
</div>
<a class="anchor" id="a2630e1cd03ffab0fee9b820bf0afe42a"></a><!-- doxytag: member="asIScriptEngine::CreateContext" ref="a2630e1cd03ffab0fee9b820bf0afe42a" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classas_i_script_context.html">asIScriptContext</a>* asIScriptEngine::CreateContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the new script context.</dd></dl>
<p>This method creates a context that will be used to execute the script functions. The context interface created will have its reference counter already increased. </p>

</div>
</div>
<a class="anchor" id="afdc06a65b6df9095835a32fa474c99d3"></a><!-- doxytag: member="asIScriptEngine::CreateScriptObject" ref="afdc06a65b6df9095835a32fa474c99d3" args="(int typeId)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* asIScriptEngine::CreateScriptObject </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeId</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">typeId</td><td>The type id of the object to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the new object if successful, or null if not.</dd></dl>
<p>This method is used to create a script object based on it's type id. The method will allocate the memory and call the object's default constructor. Reference counted objects will have their reference counter set to 1 so the application needs to release the pointer when it will no longer use it.</p>
<p>This only works for objects, for primitive types and object handles the method doesn't do anything and returns a null pointer. </p>

</div>
</div>
<a class="anchor" id="a0369a333503be2a232580a85b854779c"></a><!-- doxytag: member="asIScriptEngine::CreateScriptObjectCopy" ref="a0369a333503be2a232580a85b854779c" args="(void *obj, int typeId)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* asIScriptEngine::CreateScriptObjectCopy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the source object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">typeId</td><td>The type id of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the new object if successful, or null if not.</dd></dl>
<p>This method is used to create a copy of an existing object.</p>
<p>This only works for objects, for primitive types and object handles the method doesn't do anything and returns a null pointer. </p>

</div>
</div>
<a class="anchor" id="afb0ce55e5846eb18afdcf906aeb67cf7"></a><!-- doxytag: member="asIScriptEngine::DiscardModule" ref="afb0ce55e5846eb18afdcf906aeb67cf7" args="(const char *module)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::DiscardModule </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>The name of the module </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asNO_MODULE</td><td>The module was not found.</td></tr>
  </table>
  </dd>
</dl>
<p>Discards a module and frees its memory. Any pointers that the application holds to this module will be invalid after this call. </p>

</div>
</div>
<a class="anchor" id="a4cc5ed7ea71811655f7910d298bb5a02"></a><!-- doxytag: member="asIScriptEngine::EndConfigGroup" ref="a4cc5ed7ea71811655f7910d298bb5a02" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::EndConfigGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asERROR</td><td>Can't end a group that hasn't been begun.</td></tr>
  </table>
  </dd>
</dl>
<p>Ends the current configuration group. Once finished a config group cannot be changed, but it can be removed when it is no longer used.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="doc_adv_dynamic_config.html">Dynamic configurations</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4beff0f3d176199019c60d282e87c8d1"></a><!-- doxytag: member="asIScriptEngine::GarbageCollect" ref="a4beff0f3d176199019c60d282e87c8d1" args="(asDWORD flags=asGC_FULL_CYCLE)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GarbageCollect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code>asGC_FULL_CYCLE</code></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Set to a combination of the <a class="el" href="angelscript_8h.html#ac06582350753eb4d89d6ba9442eadf9d">asEGCFlags</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if the cycle wasn't completed, 0 if it was.</dd></dl>
<p>This method will free script objects that can no longer be reached. When the engine is released the garbage collector will automatically do a full cycle to release all objects still alive. If the engine is long living it is important to call this method every once in a while to free up memory allocated by the scripts. If a script does a lot of allocations before returning it may be necessary to implement a line callback function that calls the garbage collector during execution of the script.</p>
<p>It is not necessary to do a full cycle with every call. This makes it possible to spread out the garbage collection time over a large period, thus not impacting the responsiveness of the application.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="doc_gc.html">Garbage collection</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a58ceeafd780dea3543e0ede4106199fd"></a><!-- doxytag: member="asIScriptEngine::GCEnumCallback" ref="a58ceeafd780dea3543e0ede4106199fd" args="(void *reference)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::GCEnumCallback </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reference</td><td>A pointer to the referenced object.</td></tr>
  </table>
  </dd>
</dl>
<p>When processing the EnumReferences call the called object should call GCEnumCallback for each of the references it holds to other objects.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="doc_gc_object.html">Garbage collected objects</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae86e5444979b0abd92777be83c53fc80"></a><!-- doxytag: member="asIScriptEngine::GetDefaultArrayTypeId" ref="ae86e5444979b0abd92777be83c53fc80" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetDefaultArrayTypeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The type id, or a negative value on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asINVALID_TYPE</td><td>The default array type hasn't been registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5531bf5310a0c933aa698725a6828e5f"></a><!-- doxytag: member="asIScriptEngine::GetEngineProperty" ref="a5531bf5310a0c933aa698725a6828e5f" args="(asEEngineProp property) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="angelscript_8h.html#a76fc6994aba7ff6c685a62c273c057e3">asPWORD</a> asIScriptEngine::GetEngineProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a53c2e8a74ade77c928316396394ebe0f">asEEngineProp</a>&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">property</td><td>One of the <a class="el" href="angelscript_8h.html#a53c2e8a74ade77c928316396394ebe0f">asEEngineProp</a> values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the property, or 0 if it is an invalid property.</dd></dl>
<p>Calling this method lets you determine the current value of the engine properties. </p>

</div>
</div>
<a class="anchor" id="a6c382e818034e25ba75a7683ccd7ef23"></a><!-- doxytag: member="asIScriptEngine::GetEnumByIndex" ref="a6c382e818034e25ba75a7683ccd7ef23" args="(asUINT index, int *enumTypeId, const char **nameSpace=0, const char **configGroup=0, asDWORD *accessMask=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* asIScriptEngine::GetEnumByIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>enumTypeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>nameSpace</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>configGroup</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> *&#160;</td>
          <td class="paramname"><em>accessMask</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the enum type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">enumTypeId</td><td>Receives the type if of the enum type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nameSpace</td><td>Receives the namespace of the enum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">configGroup</td><td>Receives the config group in which the enum was registered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">accessMask</td><td>Receives the access mask of the enum. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The name of the registered enum type, or null on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b4307dab64061be43db84ffb97e3782"></a><!-- doxytag: member="asIScriptEngine::GetEnumCount" ref="a4b4307dab64061be43db84ffb97e3782" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> asIScriptEngine::GetEnumCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of registered enum types. </dd></dl>

</div>
</div>
<a class="anchor" id="acc50d55c389409e3ff699a5e4d6e4ba5"></a><!-- doxytag: member="asIScriptEngine::GetEnumValueByIndex" ref="acc50d55c389409e3ff699a5e4d6e4ba5" args="(int enumTypeId, asUINT index, int *outValue) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* asIScriptEngine::GetEnumValueByIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enumTypeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>outValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enumTypeId</td><td>The type id of the enum type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the enum value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outValue</td><td>Receives the value of the enum value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The name of the enum value. </dd></dl>

</div>
</div>
<a class="anchor" id="afe82935052b582efbfd536ebda352e98"></a><!-- doxytag: member="asIScriptEngine::GetEnumValueCount" ref="afe82935052b582efbfd536ebda352e98" args="(int enumTypeId) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetEnumValueCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enumTypeId</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enumTypeId</td><td>The type id of the enum type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of enum values for the enum type. </dd></dl>

</div>
</div>
<a class="anchor" id="a62dc5e5ba69722ea177a8e7c509d13b3"></a><!-- doxytag: member="asIScriptEngine::GetFuncdefByIndex" ref="a62dc5e5ba69722ea177a8e7c509d13b3" args="(asUINT index) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classas_i_script_function.html">asIScriptFunction</a>* asIScriptEngine::GetFuncdefByIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the funcdef. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The funcdef.</dd></dl>
<p>This function does not increase the reference count of the return function definition. </p>

</div>
</div>
<a class="anchor" id="a48aceb1556f88ce3bec3e0f84abe127f"></a><!-- doxytag: member="asIScriptEngine::GetFuncdefCount" ref="a48aceb1556f88ce3bec3e0f84abe127f" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> asIScriptEngine::GetFuncdefCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of registered funcdefs. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf67dc0b1f26be437ccbcc0ac5f330c9"></a><!-- doxytag: member="asIScriptEngine::GetFunctionById" ref="aaf67dc0b1f26be437ccbcc0ac5f330c9" args="(int funcId) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classas_i_script_function.html">asIScriptFunction</a>* asIScriptEngine::GetFunctionById </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>funcId</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">funcId</td><td>The id of the function or method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the function description interface, or null if not found.</dd></dl>
<p>This does not increment the reference count of the returned function interface. </p>

</div>
</div>
<a class="anchor" id="a166e6cdd0cb35bcfd942824d8e882783"></a><!-- doxytag: member="asIScriptEngine::GetGCStatistics" ref="a166e6cdd0cb35bcfd942824d8e882783" args="(asUINT *currentSize, asUINT *totalDestroyed=0, asUINT *totalDetected=0, asUINT *newObjects=0, asUINT *totalNewDestroyed=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::GetGCStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> *&#160;</td>
          <td class="paramname"><em>currentSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> *&#160;</td>
          <td class="paramname"><em>totalDestroyed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> *&#160;</td>
          <td class="paramname"><em>totalDetected</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> *&#160;</td>
          <td class="paramname"><em>newObjects</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> *&#160;</td>
          <td class="paramname"><em>totalNewDestroyed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">currentSize</td><td>The current number of objects known to the garbage collector. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">totalDestroyed</td><td>The total number of objects destroyed by the garbage collector. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">totalDetected</td><td>The total number of objects detected as garbage with circular references. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newObjects</td><td>The current number of objects in the new generation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">totalNewDestroyed</td><td>The total number of objects destroyed while still in the new generation.</td></tr>
  </table>
  </dd>
</dl>
<p>This method can be used to query the number of objects that the garbage collector is keeping track of. If the number is very large then it is probably time to call the <a class="el" href="classas_i_script_engine.html#a4beff0f3d176199019c60d282e87c8d1">GarbageCollect</a> method so that some of the objects ca be freed.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="doc_gc.html">Garbage collection</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a42edd02e95731c795e13706400e8665a"></a><!-- doxytag: member="asIScriptEngine::GetGlobalFunctionByDecl" ref="a42edd02e95731c795e13706400e8665a" args="(const char *declaration) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classas_i_script_function.html">asIScriptFunction</a>* asIScriptEngine::GetGlobalFunctionByDecl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>declaration</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">declaration</td><td>The signature of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function object, or null on error. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf2b79cef75adb4099a24e3412e4ea79"></a><!-- doxytag: member="asIScriptEngine::GetGlobalFunctionByIndex" ref="aaf2b79cef75adb4099a24e3412e4ea79" args="(asUINT index) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classas_i_script_function.html">asIScriptFunction</a>* asIScriptEngine::GetGlobalFunctionByIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the registered global function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The function object, or null on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a72aa1a3a5ac88a5a1dba4fa3655141d6"></a><!-- doxytag: member="asIScriptEngine::GetGlobalFunctionCount" ref="a72aa1a3a5ac88a5a1dba4fa3655141d6" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> asIScriptEngine::GetGlobalFunctionCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of registered functions. </dd></dl>

</div>
</div>
<a class="anchor" id="a154f25c36b7d88f73de1b440a169ec08"></a><!-- doxytag: member="asIScriptEngine::GetGlobalFunctionIdByIndex" ref="a154f25c36b7d88f73de1b440a169ec08" args="(asUINT index) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetGlobalFunctionIdByIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the registered global function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The id of the function, or a negative value on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asINVALID_ARG</td><td><em>index</em> is too large. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93bd686853a48647d2136792e27380fb"></a><!-- doxytag: member="asIScriptEngine::GetGlobalPropertyByIndex" ref="a93bd686853a48647d2136792e27380fb" args="(asUINT index, const char **name, const char **nameSpace=0, int *typeId=0, bool *isConst=0, const char **configGroup=0, void **pointer=0, asDWORD *accessMask=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetGlobalPropertyByIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>nameSpace</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>typeId</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isConst</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>configGroup</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pointer</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> *&#160;</td>
          <td class="paramname"><em>accessMask</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the global variable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">name</td><td>Receives the name of the property. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nameSpace</td><td>Receives the namespace of the property. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">typeId</td><td>Receives the typeId of the property. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isConst</td><td>Receives the constness indicator of the property. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">configGroup</td><td>Receives the config group in which the property was registered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pointer</td><td>Receives the pointer of the property. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">accessMask</td><td>Receives the access mask of the property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asINVALID_ARG</td><td><em>index</em> is too large. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa69f6b37f9c7bdf9b52b9c1692daf048"></a><!-- doxytag: member="asIScriptEngine::GetGlobalPropertyCount" ref="aa69f6b37f9c7bdf9b52b9c1692daf048" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> asIScriptEngine::GetGlobalPropertyCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of registered global properties. </dd></dl>

</div>
</div>
<a class="anchor" id="a91a4cc8af51ca439ca82b9b6630439b3"></a><!-- doxytag: member="asIScriptEngine::GetGlobalPropertyIndexByDecl" ref="a91a4cc8af51ca439ca82b9b6630439b3" args="(const char *decl) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetGlobalPropertyIndexByDecl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>decl</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decl</td><td>The declaration of the property to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The index of the matching property or negative on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asNO_GLOBAL_VAR</td><td>No matching property was found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07e85878869e4d0597c1177d767dc717"></a><!-- doxytag: member="asIScriptEngine::GetGlobalPropertyIndexByName" ref="a07e85878869e4d0597c1177d767dc717" args="(const char *name) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetGlobalPropertyIndexByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The index of the matching property or negative on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asNO_GLOBAL_VAR</td><td>No matching property was found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f7cdc52b59034e6e55eb8a56b427aa4"></a><!-- doxytag: member="asIScriptEngine::GetModule" ref="a9f7cdc52b59034e6e55eb8a56b427aa4" args="(const char *module, asEGMFlags flag=asGM_ONLY_IF_EXISTS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classas_i_script_module.html">asIScriptModule</a>* asIScriptEngine::GetModule </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#ae4cf50de5273eb8c03c6e91e6e014f0c">asEGMFlags</a>&#160;</td>
          <td class="paramname"><em>flag</em> = <code>asGM_ONLY_IF_EXISTS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>The name of the module </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>One of the <a class="el" href="angelscript_8h.html#ae4cf50de5273eb8c03c6e91e6e014f0c">asEGMFlags</a> flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the module interface</dd></dl>
<p>Use this method to get access to the module interface, which will let you build new scripts, and enumerate functions and types in existing modules.</p>
<p>If <a class="el" href="angelscript_8h.html#ae4cf50de5273eb8c03c6e91e6e014f0ca0843ab784ed9a9ea6cb47d915825186f">asGM_ALWAYS_CREATE</a> is informed as the flag the previous module with the same name will be discarded, thus any pointers that the engine holds to it will be invalid after the call. </p>

</div>
</div>
<a class="anchor" id="a52f3e08240c9fc493793036721cbd5ce"></a><!-- doxytag: member="asIScriptEngine::GetObjectTypeById" ref="a52f3e08240c9fc493793036721cbd5ce" args="(int typeId) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classas_i_object_type.html">asIObjectType</a>* asIScriptEngine::GetObjectTypeById </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeId</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">typeId</td><td>The type id of the type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The object type interface for the type, or null if not found.</dd></dl>
<p>This does not increment the reference count of the returned object type. </p>

</div>
</div>
<a class="anchor" id="ac0a40a93ca9df41b7e56dd846a98cd92"></a><!-- doxytag: member="asIScriptEngine::GetObjectTypeByIndex" ref="ac0a40a93ca9df41b7e56dd846a98cd92" args="(asUINT index) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classas_i_object_type.html">asIObjectType</a>* asIScriptEngine::GetObjectTypeByIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The registered object type interface for the type, or null if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c44c6cc32407c92d0bb4dfb871ee943"></a><!-- doxytag: member="asIScriptEngine::GetObjectTypeByName" ref="a4c44c6cc32407c92d0bb4dfb871ee943" args="(const char *name) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classas_i_object_type.html">asIObjectType</a>* asIScriptEngine::GetObjectTypeByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The object type or null if no match is found. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2667fbe30dd00ed14bc14e6ef7fc725"></a><!-- doxytag: member="asIScriptEngine::GetObjectTypeCount" ref="ac2667fbe30dd00ed14bc14e6ef7fc725" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> asIScriptEngine::GetObjectTypeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of object types registered by the application. </dd></dl>

</div>
</div>
<a class="anchor" id="a39b7207a6c4c55a5cbf10eab2ccfb8e6"></a><!-- doxytag: member="asIScriptEngine::GetSizeOfPrimitiveType" ref="a39b7207a6c4c55a5cbf10eab2ccfb8e6" args="(int typeId) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetSizeOfPrimitiveType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeId</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">typeId</td><td>The type id of the type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The size of the type in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bc701479de273e47e6ed6276e8fbb3e"></a><!-- doxytag: member="asIScriptEngine::GetStringFactoryReturnTypeId" ref="a0bc701479de273e47e6ed6276e8fbb3e" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetStringFactoryReturnTypeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The type id of the type that the string type returns, or a negative value on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asNO_FUNCTION</td><td>The string factory has not been registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ae23fcde6af0d816ff97097cd443281"></a><!-- doxytag: member="asIScriptEngine::GetTypeDeclaration" ref="a3ae23fcde6af0d816ff97097cd443281" args="(int typeId, bool includeNamespace=false) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* asIScriptEngine::GetTypeDeclaration </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeNamespace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">typeId</td><td>The type id of the type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">includeNamespace</td><td>Set to true if the namespace should be included in the formatted declaration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A null terminated string with the type declaration, or null if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ac7f06ad290ac619d48baaccedac7e4"></a><!-- doxytag: member="asIScriptEngine::GetTypedefByIndex" ref="a5ac7f06ad290ac619d48baaccedac7e4" args="(asUINT index, int *typeId, const char **nameSpace=0, const char **configGroup=0, asDWORD *accessMask=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* asIScriptEngine::GetTypedefByIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>nameSpace</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>configGroup</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> *&#160;</td>
          <td class="paramname"><em>accessMask</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the typedef. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">typeId</td><td>The type that the typedef aliases. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nameSpace</td><td>The namespace in which the typedef was registered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">configGroup</td><td>Receives the config group in which the type def was registered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">accessMask</td><td>The access mask for the typedef. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The name of the typedef. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ebbbb86ea0e314cc2695f6276ebe507"></a><!-- doxytag: member="asIScriptEngine::GetTypedefCount" ref="a0ebbbb86ea0e314cc2695f6276ebe507" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="angelscript_8h.html#ac8186f029686800b7ce36bde4a55c815">asUINT</a> asIScriptEngine::GetTypedefCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of registered typedefs. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1f6fecb0f53fd7966736b01f65c3dcb"></a><!-- doxytag: member="asIScriptEngine::GetTypeIdByDecl" ref="ad1f6fecb0f53fd7966736b01f65c3dcb" args="(const char *decl) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::GetTypeIdByDecl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>decl</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decl</td><td>The declaration of the type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error, or the type id of the type. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asINVALID_TYPE</td><td><em>decl</em> is not a valid type.</td></tr>
  </table>
  </dd>
</dl>
<p>Translates a type declaration into a type id. The returned type id is valid for as long as the type is valid, so you can safely store it for later use to avoid potential overhead by calling this function each time. Just remember to update the type id, any time the type is changed within the engine, e.g. when recompiling script declared classes, or changing the engine configuration.</p>
<p>The type id is based on a sequence number and depends on the order in which the type ids are queried, thus is not guaranteed to always be the same for each execution of the application. The <a class="el" href="angelscript_8h.html#ae8c3a67a97321be53181e9ed396ad83a">asETypeIdFlags</a> can be used to obtain some information about the type directly from the id.</p>
<p>A base type yields the same type id whether the declaration is const or not, however if the const is for the subtype then the type id is different, e.g. string@ isn't the same as const string@ but string is the same as const string.</p>
<p>This method is only able to return the type id that are not specific for a script module, i.e. built-in types and application registered types. Type ids for script declared types should be obtained through the script module's <a class="el" href="classas_i_script_module.html#a7fbc2bd888b248d2c2ee2d953b49eefc">GetTypeIdByDecl</a>. </p>

</div>
</div>
<a class="anchor" id="aeab55f7073163d10552e02a469b0ef78"></a><!-- doxytag: member="asIScriptEngine::GetUserData" ref="aeab55f7073163d10552e02a469b0ef78" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* asIScriptEngine::GetUserData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The pointer to the user data. </dd></dl>

</div>
</div>
<a class="anchor" id="a282b92f29b371545a6a6f6aa2ccf971e"></a><!-- doxytag: member="asIScriptEngine::IsHandleCompatibleWithObject" ref="a282b92f29b371545a6a6f6aa2ccf971e" args="(void *obj, int objTypeId, int handleTypeId) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool asIScriptEngine::IsHandleCompatibleWithObject </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>objTypeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>handleTypeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objTypeId</td><td>The type id of the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handleTypeId</td><td>The type id of the handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if the handle type is compatible with the object type.</dd></dl>
<p>This method can be used to determine if a handle of a certain type is compatible with an object of another type. This is useful if you have a pointer to a object, but only knows that it implements a certain interface and now you want to determine if it implements another interface. </p>

</div>
</div>
<a class="anchor" id="abad64f5d62458c49acba7c0d9baf1279"></a><!-- doxytag: member="asIScriptEngine::NotifyGarbageCollectorOfNewObject" ref="abad64f5d62458c49acba7c0d9baf1279" args="(void *obj, asIObjectType *type)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::NotifyGarbageCollectorOfNewObject </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classas_i_object_type.html">asIObjectType</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the newly created object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type of the object.</td></tr>
  </table>
  </dd>
</dl>
<p>This method should be called when a new garbage collected object is created. The GC will then store a reference to the object so that it can automatically detect whether the object is involved in any circular references that should be released.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="doc_gc_object.html">Garbage collected objects</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adb8d7ba77b0b24abea68ba93ac153668"></a><!-- doxytag: member="asIScriptEngine::ParseToken" ref="adb8d7ba77b0b24abea68ba93ac153668" args="(const char *string, size_t stringLength=0, int *tokenLength=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="angelscript_8h.html#a012a602727ca3fe1efa27053bc58cbca">asETokenClass</a> asIScriptEngine::ParseToken </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringLength</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>tokenLength</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string to parse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringLength</td><td>The length of the string. Can be 0 if the string is null terminated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tokenLength</td><td>Gives the length of the identified token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of the <a class="el" href="angelscript_8h.html#a012a602727ca3fe1efa27053bc58cbca">asETokenClass</a> values.</dd></dl>
<p>This function is useful for those applications that want to tokenize strings into tokens that the script language uses, e.g. IDEs providing syntax highlighting, or intellisense. It can also be used to parse the meta data strings that may be declared for script entities. </p>

</div>
</div>
<a class="anchor" id="ac9451feece1297eba8d1649036039e82"></a><!-- doxytag: member="asIScriptEngine::RegisterDefaultArrayType" ref="ac9451feece1297eba8d1649036039e82" args="(const char *type)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterDefaultArrayType </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The name of the template type, e.g. array&lt;T&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asINVALID_TYPE</td><td>The type is not a template type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abed6e77f2a532c8a4f528650fa137d37"></a><!-- doxytag: member="asIScriptEngine::RegisterEnum" ref="abed6e77f2a532c8a4f528650fa137d37" args="(const char *type)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterEnum </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The name of the enum type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asINVALID_NAME</td><td><em>type</em> is null. </td></tr>
    <tr><td class="paramname">asALREADY_REGISTERED</td><td>Another type with this name already exists. </td></tr>
    <tr><td class="paramname">asERROR</td><td>The <em>type</em> couldn't be parsed. </td></tr>
    <tr><td class="paramname">asINVALID_NAME</td><td>The <em>type</em> is not an identifier, or it is a reserved keyword. </td></tr>
    <tr><td class="paramname">asNAME_TAKEN</td><td>The type name is already taken.</td></tr>
  </table>
  </dd>
</dl>
<p>This method registers an enum type in the engine. The enum values should then be registered with <a class="el" href="classas_i_script_engine.html#a4d331153596dd39838f3bed2a861af18">RegisterEnumValue</a>. </p>

</div>
</div>
<a class="anchor" id="a4d331153596dd39838f3bed2a861af18"></a><!-- doxytag: member="asIScriptEngine::RegisterEnumValue" ref="a4d331153596dd39838f3bed2a861af18" args="(const char *type, const char *name, int value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterEnumValue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The name of the enum type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the enum value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The integer value of the enum value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asWRONG_CONFIG_GROUP</td><td>The enum <em>type</em> was registered in a different configuration group. </td></tr>
    <tr><td class="paramname">asINVALID_TYPE</td><td>The <em>type</em> is invalid. </td></tr>
    <tr><td class="paramname">asALREADY_REGISTERED</td><td>The <em>name</em> is already registered for this enum.</td></tr>
  </table>
  </dd>
</dl>
<p>This method registers an enum value for a previously registered enum type. </p>

</div>
</div>
<a class="anchor" id="a03c1a2cc23ae4b742c927f3472a1a4f7"></a><!-- doxytag: member="asIScriptEngine::RegisterFuncdef" ref="a03c1a2cc23ae4b742c927f3472a1a4f7" args="(const char *decl)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterFuncdef </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>decl</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">decl</td><td>The declaration of the function definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asINVALID_ARG</td><td>The <em>decl</em> parameter is not given. </td></tr>
    <tr><td class="paramname">asINVALID_DECLARATION</td><td><em>decl</em> is not a valid function definition. </td></tr>
    <tr><td class="paramname">asNAME_TAKEN</td><td>The name of the funcdef conflicts with another name.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="doc_datatypes_funcptr.html">Funcdefs</a> are used to define the signature of function pointers. If the application is going to receive function pointers from scripts, it is necessary to first register the funcdef before registering the function or property that will be used to receive it. </p>

</div>
</div>
<a class="anchor" id="a754fafd069d8e0c19baff2dc222893b0"></a><!-- doxytag: member="asIScriptEngine::RegisterGlobalFunction" ref="a754fafd069d8e0c19baff2dc222893b0" args="(const char *declaration, const asSFuncPtr &amp;funcPointer, asDWORD callConv)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterGlobalFunction </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>declaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>funcPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a>&#160;</td>
          <td class="paramname"><em>callConv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">declaration</td><td>The declaration of the global function in script syntax. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">funcPointer</td><td>The function pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callConv</td><td>The calling convention for the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error, or the function id if successful. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asNOT_SUPPORTED</td><td>The calling convention is not supported. </td></tr>
    <tr><td class="paramname">asWRONG_CALLING_CONV</td><td>The function's calling convention doesn't match <em>callConv</em>. </td></tr>
    <tr><td class="paramname">asINVALID_DECLARATION</td><td>The function declaration is invalid. </td></tr>
    <tr><td class="paramname">asNAME_TAKEN</td><td>The function name is already used elsewhere.</td></tr>
  </table>
  </dd>
</dl>
<p>This method registers system functions that the scripts may use to communicate with the host application.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="doc_register_func.html">Registering a function</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aacd32f32b2922b8ffaed204812013169"></a><!-- doxytag: member="asIScriptEngine::RegisterGlobalProperty" ref="aacd32f32b2922b8ffaed204812013169" args="(const char *declaration, void *pointer)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterGlobalProperty </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>declaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">declaration</td><td>The declaration of the global property in script syntax. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>The address of the property that will be used to access the property value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asINVALID_DECLARATION</td><td>The declaration has invalid syntax. </td></tr>
    <tr><td class="paramname">asINVALID_TYPE</td><td>The declaration is a reference. </td></tr>
    <tr><td class="paramname">asINVALID_ARG</td><td>The pointer is null. </td></tr>
    <tr><td class="paramname">asNAME_TAKEN</td><td>The name is already taken.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this method to register a global property that the scripts will be able to access as global variables. The property may optionally be registered as const, if the scripts shouldn't be allowed to modify it.</p>
<p>When registering the property, the application must pass the address to the actual value. The application must also make sure that this address remains valid throughout the life time of this registration, i.e. until the engine is released or the dynamic configuration group is removed. </p>

</div>
</div>
<a class="anchor" id="ae2d89b82561b7f9843f35693c664589f"></a><!-- doxytag: member="asIScriptEngine::RegisterInterface" ref="ae2d89b82561b7f9843f35693c664589f" args="(const char *name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterInterface </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the interface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asINVALID_NAME</td><td>The <em>name</em> is null, or a reserved keyword. </td></tr>
    <tr><td class="paramname">asALREADY_REGISTERED</td><td>An object type with this name already exists. </td></tr>
    <tr><td class="paramname">asERROR</td><td>The <em>name</em> is not a proper identifier. </td></tr>
    <tr><td class="paramname">asNAME_TAKEN</td><td>The <em>name</em> is already used elsewhere.</td></tr>
  </table>
  </dd>
</dl>
<p>This registers an interface that script classes can implement. By doing this the application can register functions and methods that receives an <a class="el" href="classas_i_script_object.html">asIScriptObject</a> and still be sure that the class implements certain methods needed by the application. </p>

</div>
</div>
<a class="anchor" id="a43bd2c12c94a55c22be76d209de93f1a"></a><!-- doxytag: member="asIScriptEngine::RegisterInterfaceMethod" ref="a43bd2c12c94a55c22be76d209de93f1a" args="(const char *intf, const char *declaration)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterInterfaceMethod </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>intf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>declaration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">intf</td><td>The name of the interface. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">declaration</td><td>The method declaration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asWRONG_CONFIG_GROUP</td><td>The interface was registered in another configuration group. </td></tr>
    <tr><td class="paramname">asINVALID_TYPE</td><td><em>intf</em> is not an interface type. </td></tr>
    <tr><td class="paramname">asINVALID_DECLARATION</td><td>The <em>declaration</em> is invalid. </td></tr>
    <tr><td class="paramname">asNAME_TAKEN</td><td>The method name is already taken.</td></tr>
  </table>
  </dd>
</dl>
<p>This registers a method that the class that implements the interface must have. </p>

</div>
</div>
<a class="anchor" id="a7ea3c93dea338b0287027de0e4895dcb"></a><!-- doxytag: member="asIScriptEngine::RegisterObjectBehaviour" ref="a7ea3c93dea338b0287027de0e4895dcb" args="(const char *obj, asEBehaviours behaviour, const char *declaration, const asSFuncPtr &amp;funcPointer, asDWORD callConv)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterObjectBehaviour </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a7e38df5b10ec8cbf2a688f1d114097c5">asEBehaviours</a>&#160;</td>
          <td class="paramname"><em>behaviour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>declaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>funcPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a>&#160;</td>
          <td class="paramname"><em>callConv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The name of the type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">behaviour</td><td>One of the object behaviours from <a class="el" href="angelscript_8h.html#a7e38df5b10ec8cbf2a688f1d114097c5">asEBehaviours</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">declaration</td><td>The declaration of the method in script syntax. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">funcPointer</td><td>The method or function pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callConv</td><td>The calling convention for the method or function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error, or the function id is successful. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asWRONG_CONFIG_GROUP</td><td>The object type was registered in a different configuration group. </td></tr>
    <tr><td class="paramname">asINVALID_ARG</td><td><em>obj</em> is not set, or a global behaviour is given in <em>behaviour</em>. </td></tr>
    <tr><td class="paramname">asWRONG_CALLING_CONV</td><td>The function's calling convention isn't compatible with <em>callConv</em>. </td></tr>
    <tr><td class="paramname">asNOT_SUPPORTED</td><td>The calling convention or the behaviour signature is not supported. </td></tr>
    <tr><td class="paramname">asINVALID_TYPE</td><td>The <em>obj</em> parameter is not a valid object name. </td></tr>
    <tr><td class="paramname">asINVALID_DECLARATION</td><td>The <em>declaration</em> is invalid. </td></tr>
    <tr><td class="paramname">asILLEGAL_BEHAVIOUR_FOR_TYPE</td><td>The <em>behaviour</em> is not allowed for this type. </td></tr>
    <tr><td class="paramname">asALREADY_REGISTERED</td><td>The behaviour is already registered with the same signature.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this method to register behaviour functions that will be called by the virtual machine to perform certain operations, such as memory management, math operations, comparisons, etc.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="doc_register_func.html">Registering a function</a>, <a class="el" href="doc_reg_opbeh.html">Registering operator behaviours</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6686c12ef37f4a4b1f9e90997b4756d0"></a><!-- doxytag: member="asIScriptEngine::RegisterObjectMethod" ref="a6686c12ef37f4a4b1f9e90997b4756d0" args="(const char *obj, const char *declaration, const asSFuncPtr &amp;funcPointer, asDWORD callConv)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterObjectMethod </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>declaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>funcPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a>&#160;</td>
          <td class="paramname"><em>callConv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The name of the type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">declaration</td><td>The declaration of the method in script syntax. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">funcPointer</td><td>The method or function pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callConv</td><td>The calling convention for the method or function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error, or the function id if successful. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asWRONG_CONFIG_GROUP</td><td>The object type was registered in a different configuration group. </td></tr>
    <tr><td class="paramname">asNOT_SUPPORTED</td><td>The calling convention is not supported. </td></tr>
    <tr><td class="paramname">asINVALID_TYPE</td><td>The <em>obj</em> parameter is not a valid object name. </td></tr>
    <tr><td class="paramname">asINVALID_DECLARATION</td><td>The <em>declaration</em> is invalid. </td></tr>
    <tr><td class="paramname">asNAME_TAKEN</td><td>The name conflicts with other members. </td></tr>
    <tr><td class="paramname">asWRONG_CALLING_CONV</td><td>The function's calling convention isn't compatible with <em>callConv</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this method to register a member method for the type. The method that is registered may be an actual class method, or a global function that takes the object pointer as either the first or last parameter. Or it may be a global function implemented with the generic calling convention.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="doc_register_func.html">Registering a function</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a33f3cd249307f5f11120a395579410f6"></a><!-- doxytag: member="asIScriptEngine::RegisterObjectProperty" ref="a33f3cd249307f5f11120a395579410f6" args="(const char *obj, const char *declaration, int byteOffset)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterObjectProperty </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>declaration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The name of the type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">declaration</td><td>The property declaration in script syntax. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byteOffset</td><td>The offset into the memory block where this property is found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asWRONG_CONFIG_GROUP</td><td>The object type was registered in a different configuration group. </td></tr>
    <tr><td class="paramname">asINVALID_OBJECT</td><td>The <em>obj</em> does not specify an object type. </td></tr>
    <tr><td class="paramname">asINVALID_TYPE</td><td>The <em>obj</em> parameter has invalid syntax. </td></tr>
    <tr><td class="paramname">asINVALID_DECLARATION</td><td>The <em>declaration</em> is invalid. </td></tr>
    <tr><td class="paramname">asNAME_TAKEN</td><td>The name conflicts with other members.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this method to register a member property of a class. The property must be local to the object, i.e. not a global variable or a static member. The easiest way to get the offset of the property is to use the asOFFSET macro.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>MyType {<span class="keywordtype">float</span> prop;};
 r = engine-&gt;<a class="code" href="classas_i_script_engine.html#a33f3cd249307f5f11120a395579410f6" title="Registers a property for the object type.">RegisterObjectProperty</a>(<span class="stringliteral">&quot;MyType&quot;</span>, <span class="stringliteral">&quot;float prop&quot;</span>, <a class="code" href="angelscript_8h.html#a717eccea17214bc1eb64bb9789c4915a" title="Returns the offset of an attribute in a struct.">asOFFSET</a>(MyType, prop)));
</pre></div> 
</div>
</div>
<a class="anchor" id="a29c6c087c8c5b5cdb6271cfd161cc5a6"></a><!-- doxytag: member="asIScriptEngine::RegisterObjectType" ref="a29c6c087c8c5b5cdb6271cfd161cc5a6" args="(const char *obj, int byteSize, asDWORD flags)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterObjectType </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The name of the type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byteSize</td><td>The size of the type in bytes. Only necessary for value types. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>One or more of the asEObjTypeFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The type id on success or a negative value on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asINVALID_ARG</td><td>The flags are invalid. </td></tr>
    <tr><td class="paramname">asINVALID_NAME</td><td>The name is invalid. </td></tr>
    <tr><td class="paramname">asALREADY_REGISTERED</td><td>Another type of the same name already exists. </td></tr>
    <tr><td class="paramname">asNAME_TAKEN</td><td>The name conflicts with other symbol names. </td></tr>
    <tr><td class="paramname">asLOWER_ARRAY_DIMENSION_NOT_REGISTERED</td><td>When registering an array type the array element must be a primitive or a registered type. </td></tr>
    <tr><td class="paramname">asINVALID_TYPE</td><td>The array type was not properly formed. </td></tr>
    <tr><td class="paramname">asNOT_SUPPORTED</td><td>The array type is not supported, or already in use preventing it from being overloaded.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this method to register new types that should be available to the scripts. Reference types, which have their memory managed by the application, should be registered with <a class="el" href="angelscript_8h.html#a855d86fa9ee15b9f75e553ee376b5c7aa9450e038342b36c745858d2e5ae4b861">asOBJ_REF</a>. Value types, which have their memory managed by the engine, should be registered with <a class="el" href="angelscript_8h.html#a855d86fa9ee15b9f75e553ee376b5c7aa9fc16a8ac0f30f9ff9c6568e0b7be91d">asOBJ_VALUE</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="doc_register_type.html">Registering an object type</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a95ad30812d89dee425240b49675017a4"></a><!-- doxytag: member="asIScriptEngine::RegisterStringFactory" ref="a95ad30812d89dee425240b49675017a4" args="(const char *datatype, const asSFuncPtr &amp;factoryFunc, asDWORD callConv)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterStringFactory </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>factoryFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a>&#160;</td>
          <td class="paramname"><em>callConv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>The datatype that the string factory returns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">factoryFunc</td><td>The pointer to the factory function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callConv</td><td>The calling convention of the factory function </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error, or the function id if successful. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asNOT_SUPPORTED</td><td>The calling convention is not supported. </td></tr>
    <tr><td class="paramname">asWRONG_CALLING_CONV</td><td>The function's calling convention doesn't match <em>callConv</em>. </td></tr>
    <tr><td class="paramname">asINVALID_TYPE</td><td>The <em>datatype</em> is not a valid type.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this function to register a string factory that will be called when the virtual machine finds a string constant in an expression. The string factory function will receive two parameters, the length of the string constant in bytes and a pointer to the character data. The factory should return a value to a previously registered type that will represent the string. Example:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Our string factory implementation</span>
 std::string StringFactory(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> byteLength, <span class="keyword">const</span> <span class="keywordtype">char</span> *s)
 {
     <span class="keywordflow">return</span> std::string(s, byteLength);
 }

 <span class="comment">// Registering the string factory</span>
 <span class="keywordtype">int</span> r = engine-&gt;<a class="code" href="classas_i_script_engine.html#a95ad30812d89dee425240b49675017a4" title="Registers the string factory.">RegisterStringFactory</a>(<span class="stringliteral">&quot;string&quot;</span>, <a class="code" href="angelscript_8h.html#a78f8f2c7f1c88b12e74a5ac47b4184ae" title="Returns an asSFuncPtr representing the function specified by the name.">asFUNCTION</a>(StringFactory), <a class="code" href="angelscript_8h.html#a3ec92ea3c4762e44c2df788ceccdd1e4a68ae43cc91cdfc3fa4590c9e6164e4f4" title="A cdecl function.">asCALL_CDECL</a>); assert( r &gt;= 0 );
</pre></div><p>The example assumes that the std::string type has been registered as the string type, with <a class="el" href="classas_i_script_engine.html#a29c6c087c8c5b5cdb6271cfd161cc5a6">RegisterObjectType</a>. </p>

</div>
</div>
<a class="anchor" id="addb24466769dc52be96c7e37d5305245"></a><!-- doxytag: member="asIScriptEngine::RegisterTypedef" ref="addb24466769dc52be96c7e37d5305245" args="(const char *type, const char *decl)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RegisterTypedef </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>decl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The name of the new typedef </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">decl</td><td>The datatype that the typedef represents </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asINVALID_NAME</td><td>The <em>type</em> is null. </td></tr>
    <tr><td class="paramname">asALREADY_REGISTERED</td><td>A type with the same name already exists. </td></tr>
    <tr><td class="paramname">asINVALID_TYPE</td><td>The <em>decl</em> is not a primitive type. </td></tr>
    <tr><td class="paramname">asINVALID_NAME</td><td>The <em>type</em> is not an identifier, or it is a reserved keyword. </td></tr>
    <tr><td class="paramname">asNAME_TAKEN</td><td>The name is already used elsewhere.</td></tr>
  </table>
  </dd>
</dl>
<p>This method registers an alias for a data type.</p>
<p>Currently typedefs can only be registered for built-in primitive types. </p>

</div>
</div>
<a class="anchor" id="aae91a45da75af9234b87e825b5c08b81"></a><!-- doxytag: member="asIScriptEngine::Release" ref="aae91a45da75af9234b87e825b5c08b81" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::Release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of references to this object.</dd></dl>
<p>Call this method when you will no longer use the references that you own.</p>
<p>The application is responsible for releasing references to all other script objects before releasing its last reference to the engine. If this is not done, it is possible that memory leaks occur as the engine cannot free objects kept alive by the application. </p>

</div>
</div>
<a class="anchor" id="a3660c6a075d76df0071b6df35feb227a"></a><!-- doxytag: member="asIScriptEngine::ReleaseScriptObject" ref="a3660c6a075d76df0071b6df35feb227a" args="(void *obj, int typeId)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::ReleaseScriptObject </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">typeId</td><td>The type id of the object.</td></tr>
  </table>
  </dd>
</dl>
<p>This calls the release method of the object to release the reference.</p>
<p>This only works for objects.</p>
<p>This version is slightly slower than the <a class="el" href="classas_i_script_engine.html#a643746a83d3c1ba30cae7df40558bd13">ReleaseScriptObject(void*, const asIObjectType *)</a> variant. </p>

</div>
</div>
<a class="anchor" id="a643746a83d3c1ba30cae7df40558bd13"></a><!-- doxytag: member="asIScriptEngine::ReleaseScriptObject" ref="a643746a83d3c1ba30cae7df40558bd13" args="(void *obj, const asIObjectType *type)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::ReleaseScriptObject </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classas_i_object_type.html">asIObjectType</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>A pointer to the object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The type of the object.</td></tr>
  </table>
  </dd>
</dl>
<p>This calls the release method of the object to release the reference. </p>

</div>
</div>
<a class="anchor" id="ab607be7fe727cdcce502d2beedbf4c0a"></a><!-- doxytag: member="asIScriptEngine::RemoveConfigGroup" ref="ab607be7fe727cdcce502d2beedbf4c0a" args="(const char *groupName)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::RemoveConfigGroup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>groupName</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">groupName</td><td>The name of the configuration group </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asCONFIG_GROUP_IS_IN_USE</td><td>The group is in use and cannot be removed.</td></tr>
  </table>
  </dd>
</dl>
<p>Remove the configuration group. If something in the configuration group is currently in use, the function will return with an error code. Examples of uses are compiled modules that have function calls to functions in the group and global variables of types registered in the group.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="doc_adv_dynamic_config.html">Dynamic configurations</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aafa5ed8214fc2029a6b5228e5cf60d6e"></a><!-- doxytag: member="asIScriptEngine::SetContextUserDataCleanupCallback" ref="aafa5ed8214fc2029a6b5228e5cf60d6e" args="(asCLEANCONTEXTFUNC_t callback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::SetContextUserDataCleanupCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a88ecc3288f67d86c6dd9d8d24d9980ca">asCLEANCONTEXTFUNC_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A pointer to the function</td></tr>
  </table>
  </dd>
</dl>
<p>The function given with this call will be invoked when a context is destroyed if any <a class="el" href="classas_i_script_context.html#a78e92b53c248534cd278a1498b88680d">user data</a> has been registered with the context.</p>
<p>The function is called from within the context destructor, so the callback should not be used for anything but cleaning up the user data itself. </p>

</div>
</div>
<a class="anchor" id="a570df3e676f2d9e03e87d97b8cede1c7"></a><!-- doxytag: member="asIScriptEngine::SetDefaultAccessMask" ref="a570df3e676f2d9e03e87d97b8cede1c7" args="(asDWORD defaultMask)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a> asIScriptEngine::SetDefaultAccessMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a>&#160;</td>
          <td class="paramname"><em>defaultMask</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultMask</td><td>The default access bit mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The previous default mask.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="doc_adv_access_mask.html">Access masks and exposing different interfaces</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a605f114814f1f64804c04391816d948b"></a><!-- doxytag: member="asIScriptEngine::SetDefaultNamespace" ref="a605f114814f1f64804c04391816d948b" args="(const char *nameSpace)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::SetDefaultNamespace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nameSpace</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nameSpace</td><td>The namespace that should be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asINVALID_ARG</td><td>The namespace is invalid</td></tr>
  </table>
  </dd>
</dl>
<p>Call this method to set the default namespace for which the following calls should assume. This applies to registration of the application interface and also to the functions that searches for registered entities.</p>
<p>Nested namespaces can be informed by separating them with the scope token, i.e. :: </p>

</div>
</div>
<a class="anchor" id="a1bce4e5f573a2ca0ff55163e28f761dd"></a><!-- doxytag: member="asIScriptEngine::SetEngineProperty" ref="a1bce4e5f573a2ca0ff55163e28f761dd" args="(asEEngineProp property, asPWORD value)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::SetEngineProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a53c2e8a74ade77c928316396394ebe0f">asEEngineProp</a>&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a76fc6994aba7ff6c685a62c273c057e3">asPWORD</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">property</td><td>One of the <a class="el" href="angelscript_8h.html#a53c2e8a74ade77c928316396394ebe0f">asEEngineProp</a> values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The new value of the property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Negative value on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asINVALID_ARG</td><td>Invalid property.</td></tr>
  </table>
  </dd>
</dl>
<p>With this method you can change the way the script engine works in some regards. </p>

</div>
</div>
<a class="anchor" id="ad91d8c1e53489bee1243e351be7e18a9"></a><!-- doxytag: member="asIScriptEngine::SetEngineUserDataCleanupCallback" ref="ad91d8c1e53489bee1243e351be7e18a9" args="(asCLEANENGINEFUNC_t callback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::SetEngineUserDataCleanupCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#ab4583fe7648248c59f525f944cfb9db1">asCLEANENGINEFUNC_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A pointer to the function</td></tr>
  </table>
  </dd>
</dl>
<p>The function given with this call will be invoked when the engine is destroyed if any <a class="el" href="classas_i_script_engine.html#a339b31c7aea69e4132ae7cebc55f3e80">user data</a> has been registered with the engine.</p>
<p>The function is called from within the engine destructor, so the callback should not be used for anything but cleaning up the user data itself. </p>

</div>
</div>
<a class="anchor" id="ae9585d4e65618b02c6005d3beaca4377"></a><!-- doxytag: member="asIScriptEngine::SetFunctionUserDataCleanupCallback" ref="ae9585d4e65618b02c6005d3beaca4377" args="(asCLEANFUNCTIONFUNC_t callback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::SetFunctionUserDataCleanupCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#ae396d162d9d46c34a7f197ecbc788dfa">asCLEANFUNCTIONFUNC_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A pointer to the function</td></tr>
  </table>
  </dd>
</dl>
<p>The function given with this call will be invoked when a function is destroyed if any <a class="el" href="classas_i_script_function.html#a2d01c604a619cbb9a4356a05d041e252">user data</a> has been registered with the function.</p>
<p>The function is called from within the function destructor, so the callback should not be used for anything but cleaning up the user data itself. </p>

</div>
</div>
<a class="anchor" id="a74192fe950808eb72a64e3e371f0ea02"></a><!-- doxytag: member="asIScriptEngine::SetMessageCallback" ref="a74192fe950808eb72a64e3e371f0ea02" args="(const asSFuncPtr &amp;callback, void *obj, asDWORD callConv)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::SetMessageCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structas_s_func_ptr.html">asSFuncPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a5428f0c940201e5f3bbb28304aeb81bc">asDWORD</a>&#160;</td>
          <td class="paramname"><em>callConv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A function or class method pointer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The object for methods, or an optional parameter for functions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callConv</td><td>The calling convention. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value for an error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asINVALID_ARG</td><td>One of the arguments is incorrect, e.g. obj is null for a class method. </td></tr>
    <tr><td class="paramname">asNOT_SUPPORTED</td><td>The arguments are not supported, e.g. asCALL_GENERIC.</td></tr>
  </table>
  </dd>
</dl>
<p>This method sets the callback routine that will receive compiler messages. The callback routine can be either a class method, e.g: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> MyClass::MessageCallback(<span class="keyword">const</span> <a class="code" href="structas_s_message_info.html" title="Represents a compiler message.">asSMessageInfo</a> *msg);
 r = engine-&gt;<a class="code" href="classas_i_script_engine.html#a74192fe950808eb72a64e3e371f0ea02" title="Sets a message callback that will receive compiler messages.">SetMessageCallback</a>(<a class="code" href="angelscript_8h.html#a7345e6b3afabec24efd0ff77886d49a6" title="Returns an asSFuncPtr representing the class method specified by class and method name...">asMETHOD</a>(MyClass,MessageCallback), &amp;obj, <a class="code" href="angelscript_8h.html#a3ec92ea3c4762e44c2df788ceccdd1e4aea516c8742acc1edff6a43dc1bb09e96" title="A thiscall class method.">asCALL_THISCALL</a>);
</pre></div><p> or a global function, e.g: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> MessageCallback(<span class="keyword">const</span> <a class="code" href="structas_s_message_info.html" title="Represents a compiler message.">asSMessageInfo</a> *msg, <span class="keywordtype">void</span> *param);
 r = engine-&gt;<a class="code" href="classas_i_script_engine.html#a74192fe950808eb72a64e3e371f0ea02" title="Sets a message callback that will receive compiler messages.">SetMessageCallback</a>(<a class="code" href="angelscript_8h.html#a78f8f2c7f1c88b12e74a5ac47b4184ae" title="Returns an asSFuncPtr representing the function specified by the name.">asFUNCTION</a>(MessageCallback), param, <a class="code" href="angelscript_8h.html#a3ec92ea3c4762e44c2df788ceccdd1e4a68ae43cc91cdfc3fa4590c9e6164e4f4" title="A cdecl function.">asCALL_CDECL</a>);
</pre></div><p> It is recommended to register the message callback routine right after creating the engine, as some of the registration functions can provide useful information to better explain errors. </p>

</div>
</div>
<a class="anchor" id="afb7a5e52a2232262ef2863e58bb2c7d1"></a><!-- doxytag: member="asIScriptEngine::SetModuleUserDataCleanupCallback" ref="afb7a5e52a2232262ef2863e58bb2c7d1" args="(asCLEANMODULEFUNC_t callback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::SetModuleUserDataCleanupCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a90d681aba2f00b701425d4dbdca3375b">asCLEANMODULEFUNC_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A pointer to the function</td></tr>
  </table>
  </dd>
</dl>
<p>The function given with this call will be invoked when the module is destroyed if any <a class="el" href="classas_i_script_module.html#aa6560a0c5e187695664da2859a9da437">user data</a> has been registered with the module.</p>
<p>The function is called from within the module destructor, so the callback should not be used for anything but cleaning up the user data itself. </p>

</div>
</div>
<a class="anchor" id="a7495c0b6307bb983ff807a3c31c4f938"></a><!-- doxytag: member="asIScriptEngine::SetObjectTypeUserDataCleanupCallback" ref="a7495c0b6307bb983ff807a3c31c4f938" args="(asCLEANOBJECTTYPEFUNC_t callback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void asIScriptEngine::SetObjectTypeUserDataCleanupCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a8bbbe3a90082461266acf8f98ce9216e">asCLEANOBJECTTYPEFUNC_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>A pointer to the function</td></tr>
  </table>
  </dd>
</dl>
<p>The function given with this call will be invoked when an object type is destroyed if any <a class="el" href="classas_i_object_type.html#a4d542ed1b449f83f712c38bf27f78821">user data</a> has been registered with the type.</p>
<p>The function is called from within the object type destructor, so the callback should not be used for anything but cleaning up the user data itself. </p>

</div>
</div>
<a class="anchor" id="a339b31c7aea69e4132ae7cebc55f3e80"></a><!-- doxytag: member="asIScriptEngine::SetUserData" ref="a339b31c7aea69e4132ae7cebc55f3e80" args="(void *data)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* asIScriptEngine::SetUserData </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A pointer to the user data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The previous pointer stored in the engine.</dd></dl>
<p>This method allows the application to associate a value, e.g. a pointer, with the engine instance.</p>
<p>Optionally, a callback function can be <a class="el" href="classas_i_script_engine.html#ad91d8c1e53489bee1243e351be7e18a9">registered</a> to clean up the user data when the engine is destroyed. </p>

</div>
</div>
<a class="anchor" id="a936ce6566af958bb75ba1c0945d8b03a"></a><!-- doxytag: member="asIScriptEngine::WriteMessage" ref="a936ce6566af958bb75ba1c0945d8b03a" args="(const char *section, int row, int col, asEMsgType type, const char *message)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int asIScriptEngine::WriteMessage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>section</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="angelscript_8h.html#a8badcd23652646db5c5c6981dc73d4f5">asEMsgType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">section</td><td>The name of the script section. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>The row number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>The column number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The message type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>The message text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A negative value on error. </dd></dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">asINVALID_ARG</td><td>The section or message is null.</td></tr>
  </table>
  </dd>
</dl>
<p>This method can be used by the application to write messages to the same message callback that the script compiler uses. This is useful for example if a preprocessor is used. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="angelscript_8h.html">angelscript.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="classas_i_script_engine.html">asIScriptEngine</a>      </li>

    <li class="footer">Generated on Sat Apr 28 2012 10:54:05 for AngelScript by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
